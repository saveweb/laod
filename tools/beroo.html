<h1 id="title">BeRoot 一款Windows系统下不错的提权工具</h1>
<time id="date" datetime="2017-04-26T14:31:48+08:00">2017-04-26 14:31</time>
<section id="content">
    <p>
        <a href="https://laod.cn/wp-content/uploads/2017/04/BeRoo.png"
            ><noscript
                ><img
                    class="alignnone size-full wp-image-3468"
                    src="https://laod.cn/wp-content/uploads/2017/04/BeRoo.png"
                    alt="BeRoo"
                    width="900"
                    height="450" /></noscript
            ><img
                class="alignnone size-full wp-image-3468 j-lazy"
                src="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20900%20450'%3E%3C/svg%3E"
                data-original="https://laod.cn/wp-content/uploads/2017/04/BeRoo.png"
                alt="BeRoo"
                width="900"
                height="450"
                data-lazy-src="https://laod.cn/wp-content/themes/justnews/themer/assets/images/lazy.png" /><noscript
                ><img
                    class="alignnone size-full wp-image-3468 j-lazy"
                    src="https://laod.cn/wp-content/themes/justnews/themer/assets/images/lazy.png"
                    data-original="https://laod.cn/wp-content/uploads/2017/04/BeRoo.png"
                    alt="BeRoo"
                    width="900"
                    height="450" /></noscript
        ></a>
    </p>
    <h4>工具简介</h4>
    <p>
        <b
            >BeRoot是一款Post-Exploitation工具，也就是在黑客拿到目标主机的Shell之后所要用到的一种东西。BeRoot可以帮助我们检查目标Windows系统中存在的错误配置，并找出提权的方法。【<a
                href="https://github.com/AlessandroZ/BeRoot"
                >GitHub传送门</a
            >】</b
        >
    </p>
    <p>
        BeRoot项目将会作为一个Post-Exploitation模块被添加进<a
            href="https://github.com/n1nj4sec/pupy/"
            >Pupy项目</a
        >（一个开源的、跨平台Post-Exploitation工具，采用Python编写）中，当beRoot作为一个模块添加进去之后，它就可以直接在内存中运行了，整个过程都无需与磁盘交互。
    </p>
    <p>
        需要注意的是，这款工具只能用来检测，而无法直接利用目标系统中存在的漏洞。但是，如果它发现了错误配置，它可以通过模版来利用这些漏洞。模版文件位于templates/service目录下，如果项目提供的模版文件无法运行，我们也可以根据目标系统的情况手动创建一个模版文件。
    </p>
    <p>
        <a
            href="https://laod.cn/wp-content/uploads/2017/04/Post-Exploitation.png"
            ><noscript
                ><img
                    class="alignnone size-full wp-image-3469"
                    src="https://laod.cn/wp-content/uploads/2017/04/Post-Exploitation.png"
                    alt="Post-Exploitation"
                    width="900"
                    height="189" /></noscript
            ><img
                class="alignnone size-full wp-image-3469 j-lazy"
                src="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20900%20189'%3E%3C/svg%3E"
                data-original="https://laod.cn/wp-content/uploads/2017/04/Post-Exploitation.png"
                alt="Post-Exploitation"
                width="900"
                height="189"
                data-lazy-src="https://laod.cn/wp-content/themes/justnews/themer/assets/images/lazy.png" /><noscript
                ><img
                    class="alignnone size-full wp-image-3469 j-lazy"
                    src="https://laod.cn/wp-content/themes/justnews/themer/assets/images/lazy.png"
                    data-original="https://laod.cn/wp-content/uploads/2017/04/Post-Exploitation.png"
                    alt="Post-Exploitation"
                    width="900"
                    height="189" /></noscript
        ></a>
    </p>
    <h4>工具下载</h4>
    <blockquote>
        <p>
            【<a
                href="https://github.com/AlessandroZ/BeRoot/releases/download/1.0/beRoot.zip"
                >beRoot.zip</a
            >】（zip）
        </p>
        <p>
            【<a href="https://github.com/AlessandroZ/BeRoot/archive/1.0.zip"
                >源代码</a
            >】（zip）
        </p>
        <p>
            【<a href="https://github.com/AlessandroZ/BeRoot/archive/1.0.tar.gz"
                >源代码</a
            >】（tar.gz）
        </p>
    </blockquote>
    <h4>工具运行</h4>
    <p>
        <a href="https://laod.cn/wp-content/uploads/2017/04/BeRoot.png"
            ><noscript
                ><img
                    class="alignnone size-full wp-image-3470"
                    src="https://laod.cn/wp-content/uploads/2017/04/BeRoot.png"
                    alt="BeRoot"
                    width="900"
                    height="434" /></noscript
            ><img
                class="alignnone size-full wp-image-3470 j-lazy"
                src="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20900%20434'%3E%3C/svg%3E"
                data-original="https://laod.cn/wp-content/uploads/2017/04/BeRoot.png"
                alt="BeRoot"
                width="900"
                height="434"
                data-lazy-src="https://laod.cn/wp-content/themes/justnews/themer/assets/images/lazy.png" /><noscript
                ><img
                    class="alignnone size-full wp-image-3470 j-lazy"
                    src="https://laod.cn/wp-content/themes/justnews/themer/assets/images/lazy.png"
                    data-original="https://laod.cn/wp-content/uploads/2017/04/BeRoot.png"
                    alt="BeRoot"
                    width="900"
                    height="434" /></noscript
        ></a>
    </p>
    <p>接下来，我们会给大家介绍所有的检测方法。</p>
    <p>&nbsp;</p>
    <h4>包含空格且不含引号的路径地址</h4>
    <p>请大家先看看下面这个文件路径：</p>
    <div class="dp-highlighter">
        <ol class="dp-py" start="1">
            <li class="alt">C:\Program&nbsp;Files\Some&nbsp;Test\binary.exe</li>
        </ol>
    </div>
    <p>
        如果文件路径中包含空格且不含引号，那么Windows系统将会按照下面的顺序定位并执行目标程序：
    </p>
    <div class="dp-highlighter">
        <ol class="dp-py" start="1">
            <li class="alt">C:\Program.exe</li>
            <li class="">C:\Program&nbsp;Files\Some.exe</li>
            <li class="alt">
                C:\Program&nbsp;Files\Some&nbsp;Folder\binary.exe
            </li>
        </ol>
    </div>
    <p>
        如果“C:\”文件夹是可写的，那么我们就有可能在该目录下创建一个恶意的可执行程序“Program.exe”，如果“binary.exe”拥有高权限，那么我们就可以利用这种机制来提升我们的权限。
    </p>
    <p>
        请注意：BeRoot会对每一条服务路径、计划任务、以及HKLM条目中的启动键执行这样的检测，
    </p>
    <h4>利用方法</h4>
    <p>在利用存在安全缺陷的路径时，我们应该遵循以下方法：</p>
    <blockquote>
        <p>
            1.
            如果是一个服务，那么我们就创建一个恶意服务（或编译一个service模版）。
        </p>
        <p>2. 如果是一个可执行程序，那么我们就可以创建一个恶意的可执行程序。</p>
    </blockquote>
    <h4>可写的文件目录</h4>
    <p>请大家先看看下面这个文件路径：</p>
    <blockquote>
        <p>
            <span class="hljs-selector-tag">C</span>:\<span
                class="hljs-selector-tag"
                >Program</span
            >
            <span class="hljs-selector-tag">Files</span>\<span
                class="hljs-selector-tag"
                >Some</span
            >
            <span class="hljs-selector-tag">Test</span>\<span
                class="hljs-selector-tag"
                >binary</span
            ><span class="hljs-selector-class">.exe</span>
        </p>
    </blockquote>
    <p>
        如果“binary.exe”所在的根目录可写（“C:\ProgramFiles\Some
        Test”），并且“binary.exe”能够以高级权限运行，那么我们就可以利用它来实现提权。
    </p>
    <p>
        请注意：BeRoot会对每一条服务路径、计划任务、以及HKLM条目中的启动键执行这样的检测，
    </p>
    <h4>利用方法</h4>
    <blockquote>
        <p>
            1.&nbsp;&nbsp;&nbsp;&nbsp;如果服务不处于运行状态：用我们的服务模版替换掉合法服务，重启该服务，并尝试触发该服务。
        </p>
        <p>
            2.&nbsp;&nbsp;&nbsp;&nbsp;服务处于运行状态且无法被终止：这是大多数的情况，可以尝试进行DLL劫持并使用其他的技术来重启服务。
        </p>
    </blockquote>
    <h4>%PATH%路径中的可写目录</h4>
    <p>这项技术可在以下Windows版本中使用：</p>
    <blockquote>
        <p>6.0&nbsp; =&gt;&nbsp; Windows Vista / Windows Server 2008</p>
        <p>6.1&nbsp; =&gt;&nbsp; Windows 7 / Windows Server 2008 R2</p>
        <p>6.2&nbsp; =&gt;&nbsp; Windows 8 / Windows Server 2012</p>
        <p>
            在上述Windows版本中，DLL文件是通过指令代码进行加载的，Windows会通过下列步骤来尝试定位相应的代码：
        </p>
        <p>&nbsp;</p>
        <p>– 定位代码所在目录</p>
        <p>– C:\Windows\System32</p>
        <p>– C:\Windows\System</p>
        <p>– C:\Windows\</p>
        <p>– 当前目录下的代码已启动</p>
        <p>– 目录地址将会保存在%PATH%环境变量中</p>
    </blockquote>
    <p>
        如果%PATH%变量中的目录路径是可写的，那么我们就有可能实现DDL劫持攻击。那么接下来，我们的目标就是要找出一个能够加载DLL文件但路径还不在%PATH%变量中的服务。默认情况下，我们选择使用“IKEEXT”服务，它可以加载我们的恶意DLL文件-wlbsctrl.dll。
    </p>
    <p>
        如何利用：创建一个名为“wlbsctrl.dll”（使用DLL模版）的恶意DLL文件，并将其添加至%PATH%变量中的可写路径，开启“IKEEXT”服务，为了在没有高级权限的情况下开启IKEEXT服务，我们可以参考法国杂志MISC90中所介绍的方法，方法大致如下：
    </p>
    <p>根据下列信息创建一个文件：</p>
    <blockquote>
        <p>C:\Users\bob\Desktop&gt;typetest.txt</p>
        <p>[IKEEXTPOC]</p>
        <p>MEDIA=rastapi</p>
        <p>Port=VPN2-0</p>
        <p>Device=Wan Miniport (IKEv2)</p>
        <p>DEVICE=vpn</p>
        <p>PhoneNumber=127.0.0.1</p>
    </blockquote>
    <p>
        使用“rasdial”命令开启IKEEXT服务，如果链接失效，则说明该服务已经处于运行状态了。
    </p>
    <h4>MS16-075</h4>
    <p>对于懂法语的用户，我建议可以参考MISC 90中提供的技术细节。</p>
    <p>
        微软已经在公告MS16-075的补丁中修复了这个漏洞，但是很多服务器仍然存在这个问题，这里给大家提供一个C++PoC【<a
            href="https://github.com/secruul/SysExec"
            >点我获取</a
        >】。大致的实现方法如下：
    </p>
    <blockquote>
        <p>
            1.&nbsp;&nbsp;&nbsp;&nbsp;使用某些方法（使用其UUID）开启Webclient服务
        </p>
        <p>2.&nbsp;&nbsp;&nbsp;&nbsp;在本地开启一个HTTP服务器</p>
        <p>3.&nbsp;&nbsp;&nbsp;&nbsp;找到一个能够触发SYSTEM NTLM哈希的服务</p>
        <p>
            4.&nbsp;&nbsp;&nbsp;&nbsp;启用该服务的文件追踪，修改其注册表键值，并让其指向我们的Web服务器（\\<a
                class="__yjs_email__"
                href="/cdn-cgi/l/email-protection"
                data-yjsemail="b18083869f819f819f80f1c1dec3c5"
                >[email&nbsp;protected]</a
            >
            <script data-yjshash="f9e31" type="text/javascript">
                /* <![CDATA[ */ !(function (t, e, r, n, c, a, p) {
                    try {
                        t =
                            document.currentScript ||
                            (function () {
                                for (
                                    t = document.getElementsByTagName("script"),
                                        e = t.length;
                                    e--;

                                )
                                    if (t[e].getAttribute("data-yjshash"))
                                        return t[e];
                            })();
                        if (t && (c = t.previousSibling)) {
                            p = t.parentNode;
                            if ((a = c.getAttribute("data-yjsemail"))) {
                                for (
                                    e = "",
                                        r = ("0x" + a.substr(0, 2)) | 0,
                                        n = 2;
                                    a.length - n;
                                    n += 2
                                )
                                    e +=
                                        "%" +
                                        (
                                            "0" +
                                            (
                                                ("0x" + a.substr(n, 2)) ^
                                                r
                                            ).toString(16)
                                        ).slice(-2);
                                p.replaceChild(
                                    document.createTextNode(
                                        decodeURIComponent(e)
                                    ),
                                    c
                                );
                            }
                            p.removeChild(t);
                        }
                    } catch (u) {}
                })(); /* ]]> */
            </script>
            \tracing）
        </p>
        <p>5.&nbsp;&nbsp;&nbsp;&nbsp;开启该服务</p>
        <p>
            6.&nbsp;&nbsp;&nbsp;&nbsp;让我们的HTTP服务器请求获取SYSTEM NTLM哈希
        </p>
        <p>
            7.&nbsp;&nbsp;&nbsp;&nbsp;使用这个哈希和SMB来执行我们的自定义Payload
        </p>
        <p>8.&nbsp;&nbsp;&nbsp;&nbsp;清除痕迹（终止服务，清除注册表键等等）</p>
    </blockquote>
    <p>如何利用：在目标主机中，BeRoot可以通过下列命令来执行自定义命令：</p>
    <blockquote>
        <blockquote>
            <p>beRoot.exe -c “net userZapata LaLuchaSigue /add”</p>
            <p>beRoot.exe -c “net localgroupAdministrators Zapata /add”</p>
        </blockquote>
    </blockquote>
    <h2>注册表键AlwaysInstallElevated</h2>
    <p>
        通过对AlwaysInstallElevated进行设置，我们可以让非特权用户使用高级权限（SYSTEM权限）来运行MicrosoftWindows
        Installer包文件。为此，我们需要将下面这两个注册表键值设置为1:
    </p>
    <blockquote>
        <p>
            HKEY_CURRENT_USER\SOFTWARE\Policies\Microsoft\Windows\Installer\AlwaysInstallElevated
        </p>
        <p>
            HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\Installer\AlwaysInstallElevated
        </p>
    </blockquote>
    <p>如何利用：创建一个恶意MSI文件，然后执行。</p>
    <h4>Unattend安装文件</h4>
    <p>
        很多安装文件中包含程序的所有配置信息，并且会在程序的安装过程中对程序进行配置，而有些安装文件中还包含对本地账号（例如管理员账号）的配置信息，我们可以通过下列路径获取到这些文件：
    </p>
    <blockquote>
        <p>
            <span class="hljs-selector-tag">C</span>:\<span
                class="hljs-selector-tag"
                >Windows</span
            >\<span class="hljs-selector-tag">Panther</span>\<span
                class="hljs-selector-tag"
                >Unattend</span
            ><span class="hljs-selector-class">.xml</span>
        </p>
        <p>
            <span class="hljs-selector-class">C</span>:\<span
                class="hljs-selector-tag"
                >Windows</span
            >\<span class="hljs-selector-tag">Panther</span>\<span
                class="hljs-selector-tag"
                >Unattended</span
            ><span class="hljs-selector-class">.xml</span>
        </p>
        <p>
            <span class="hljs-selector-class">C</span>:\<span
                class="hljs-selector-tag"
                >Windows</span
            >\<span class="hljs-selector-tag">Panther</span>\<span
                class="hljs-selector-tag"
                >Unattend</span
            >\<span class="hljs-selector-tag">Unattended</span
            ><span class="hljs-selector-class">.xml</span>
        </p>
        <p>
            <span class="hljs-selector-class">C</span>:\<span
                class="hljs-selector-tag"
                >Windows</span
            >\<span class="hljs-selector-tag">Panther</span>\<span
                class="hljs-selector-tag"
                >Unattend</span
            >\<span class="hljs-selector-tag">Unattend</span
            ><span class="hljs-selector-class">.xml</span>
        </p>
        <p>
            <span class="hljs-selector-class">C</span>:\<span
                class="hljs-selector-tag"
                >Windows</span
            >\<span class="hljs-selector-tag">System32</span>\<span
                class="hljs-selector-tag"
                >Sysprep</span
            >\<span class="hljs-selector-tag">unattend</span
            ><span class="hljs-selector-class">.xml</span>
        </p>
        <p>
            <span class="hljs-selector-tag">C</span>:\<span
                class="hljs-selector-tag"
                >Windows</span
            >\<span class="hljs-selector-tag">System32</span>\<span
                class="hljs-selector-tag"
                >Sysprep</span
            >\<span class="hljs-selector-tag">Panther</span>\<span
                class="hljs-selector-tag"
                >unattend</span
            ><span class="hljs-selector-class">.xml</span>
        </p>
    </blockquote>
    <p>
        如何利用：打开unattend.xml文件，检查其中是否含有密码。文件结构大致如下：
    </p>
    <blockquote>
        <p><span class="hljs-params">&lt;UserAccounts&gt;</span></p>
        <p><span class="hljs-params">&lt;LocalAccounts&gt;</span></p>
        <p><span class="hljs-params">&lt;LocalAccount&gt;</span></p>
        <p><span class="hljs-params">&lt;Password&gt;</span></p>
        <p>
            <span class="hljs-params">&lt;Value&gt;</span>RmFrZVBhc3N3MHJk<span
                class="hljs-params"
                >&lt;/Value&gt;</span
            >
        </p>
        <p>
            <span class="hljs-params">&lt;PlainText&gt;</span>false<span
                class="hljs-params"
                >&lt;/PlainText&gt;</span
            >
        </p>
        <p><span class="hljs-params">&lt;/Password&gt;</span></p>
        <p>
            <span class="hljs-params">&lt;Description&gt;</span>Local
            Administrator<span class="hljs-params">&lt;/Description&gt;</span>
        </p>
        <p>
            <span class="hljs-params">&lt;DisplayName&gt;</span
            >Administrator<span class="hljs-params">&lt;/DisplayName&gt;</span>
        </p>
        <p>
            <span class="hljs-params">&lt;Group&gt;</span>Administrators<span
                class="hljs-params"
                >&lt;/Group&gt;</span
            >
        </p>
        <p>
            <span class="hljs-params">&lt;Name&gt;</span>Administrator<span
                class="hljs-params"
                >&lt;/Name&gt;</span
            >
        </p>
        <p><span class="hljs-params">&lt;/LocalAccount&gt;</span></p>
        <p><span class="hljs-params">&lt;/LocalAccounts&gt;</span></p>
        <p><span class="hljs-params">&lt;/UserAccounts&gt;</span></p>
    </blockquote>
    <div class="entry-copyright">
        <p>
            原创文章，作者：老D，如若转载，请注明出处：https://laod.cn/tools/beroo.html
        </p>
    </div>
</section>
